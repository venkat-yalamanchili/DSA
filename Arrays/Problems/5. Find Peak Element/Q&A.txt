A peak element is an element that is strictly greater than its neighbors.

Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.

You may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.

You must write an algorithm that runs in O(log n) time.

Example 1:

Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
Example 2:

Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.



Solution: Perform binary seacrh (Hint)
Explanation: Compare mid vs mid+1

At any point, look at the middle and its right neighbor:

If nums[mid] < nums[mid+1], we’re on an ascending slope → a peak lies to the right (could be mid+1 or further).

If nums[mid] > nums[mid+1], we’re on a descending slope → a peak lies to the left or at mid.

Case A: ascending                Case B: descending
         ^                                       ^
        / \                                     / \
 ...  a/   \b      (a < b)          ...      a/   \b      (a > b)
      mid  mid+1                                mid  mid+1
 move right (l = mid+1)                move left (r = mid)


By always moving toward the higher side, you never skip all peaks: the slope guarantees a peak somewhere in that direction.

Algorithm (binary search on slopes)

Set l = 0, r = n-1.

While l < r:

Let mid = (l + r) // 2.

If nums[mid] < nums[mid+1], set l = mid + 1 (go right).

Else set r = mid (go left, keeping mid because it could be the peak).

When the loop ends, l == r and that index is a peak.

This avoids out-of-bounds checks on mid-1 by only comparing mid to mid+1.

Why it works

On an ascending step, the right side must contain a peak (eventually it must stop increasing or hit the boundary, which behaves like -∞ beyond and yields a peak).

On a descending step, the left side (including mid) must contain a peak by similar reasoning.

Each step halves the search space ⇒ O(log n) time, O(1) space.